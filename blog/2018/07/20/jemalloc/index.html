<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>Apache Arrow Homepage</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jekyll v3.4.3">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic,900">

    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
    <script src="/assets/javascripts/bootstrap.min.js"></script>
    
    <!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-107500873-1');
</script>

    
  </head>



<body class="wrap">
  <div class="container">
    <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#arrow-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Apache Arrow&#8482;&nbsp;&nbsp;&nbsp;</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="arrow-navbar">
      <ul class="nav navbar-nav">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown"
             role="button" aria-haspopup="true"
             aria-expanded="false">Project Links<span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/install/">Install</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="/release/">Releases</a></li>
            <li><a href="https://issues.apache.org/jira/browse/ARROW">Issue Tracker</a></li>
            <li><a href="https://github.com/apache/arrow">Source Code</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown"
             role="button" aria-haspopup="true"
             aria-expanded="false">Community<span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="http://mail-archives.apache.org/mod_mbox/arrow-dev/">Mailing List</a></li>
            <li><a href="https://cwiki.apache.org/confluence/display/ARROW">Developer Wiki</a></li>
            <li><a href="/committers/">Committers</a></li>
            <li><a href="/powered_by/">Powered By</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown"
             role="button" aria-haspopup="true"
             aria-expanded="false">Specification<span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/docs/memory_layout.html">Memory Layout</a></li>
            <li><a href="/docs/metadata.html">Metadata</a></li>
            <li><a href="/docs/ipc.html">Messaging / IPC</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown"
             role="button" aria-haspopup="true"
             aria-expanded="false">Documentation<span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/docs/python">Python</a></li>
            <li><a href="/docs/cpp">C++ API</a></li>
            <li><a href="/docs/java">Java API</a></li>
            <li><a href="/docs/c_glib">C GLib API</a></li>
            <li><a href="/docs/js">Javascript API</a></li>
          </ul>
        </li>
        <!-- <li><a href="/blog">Blog</a></li> -->
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown"
             role="button" aria-haspopup="true"
             aria-expanded="false">ASF Links<span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="http://www.apache.org/">ASF Website</a></li>
            <li><a href="http://www.apache.org/licenses/">License</a></li>
            <li><a href="http://www.apache.org/foundation/sponsorship.html">Donate</a></li>
            <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
            <li><a href="http://www.apache.org/security/">Security</a></li>
          </ul>
        </li>
      </ul>
      <a href="http://www.apache.org/">
        <img style="float:right;" src="/img/asf_logo.svg" width="120px"/>
      </a>
      </div><!-- /.navbar-collapse -->
    </div>
  </nav>


    <h2>
      Faster, scalable memory allocations in Apache Arrow with jemalloc
      <a href="/blog/2018/07/20/jemalloc/" class="permalink" title="Permalink">∞</a>
    </h2>

    

    <div class="panel">
      <div class="panel-body">
        <div>
          <span class="label label-default">Published</span>
          <span class="published">
            <i class="fa fa-calendar"></i>
            20 Jul 2018
          </span>
        </div>
        <div>
          <span class="label label-default">By</span>
          <a href="http://github.com/xhochy"><i class="fa fa-user"></i> Uwe Korn (uwe)</a>
        </div>
      </div>
    </div>

    <!--

-->

<p>With the release of the 0.9 version of Apache Arrow, we have switched our
default allocator for array buffers from the system allocator to jemalloc on
OSX and Linux. This applies to the C++/GLib/Python implementations of Arrow.
In most cases changing the default allocator is normally done to avoid problems
that occur with many small, frequent (de)allocations. In contrast, in Arrow we
normally deal with large in-memory datasets. While jemalloc provides good
strategies for <a href="https://zapier.com/engineering/celery-python-jemalloc/">avoiding RAM fragmentation for allocations that are lower than
a memory page (4kb)</a>, it also provides functionality that improves
performance on allocations that span several memory pages.</p>

<p>Outside of Apache Arrow, <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919/">jemalloc powers the infrastructure of Facebook</a>
(this is also where most of its development happens). It is also used as the
<a href="https://github.com/rust-lang/rust/pull/6895">default allocator in Rust</a> as well as it helps <a href="http://download.redis.io/redis-stable/README.md">Redis reduce the memory
fragmentation on Linux</a> (“Allocator”).</p>

<p>One allocation specialty that we require in Arrow is that memory should be
64byte aligned. This is so that we can get the most performance out of SIMD
instruction sets like AVX. While the most modern SIMD instructions also work on
unaligned memory, their performance is much better on aligned memory. To get the
best performance for our analytical applications, we want all memory to be
allocated such that SIMD performance is maximized.</p>

<p>For aligned allocations, the POSIX APIs only provide the
<code class="highlighter-rouge">aligned_alloc(void** ptr, size_t alignment, size_t size)</code> function to
allocate aligned memory. There is also 
<code class="highlighter-rouge">posix_memalign(void **ptr, size_t alignment, size_t size)</code> to modify an
allocation to the preferred alignment. But neither of them cater for expansions
of the allocation. While the <code class="highlighter-rouge">realloc</code> function can often expand allocations
without moving them physically, it does not ensure that in the case the
allocation is moved that the alignment is kept.</p>

<p>In the case when Arrow was built without jemalloc being enabled, this resulted
in copying the data on each new expansion of an allocation. To reduce the number
of memory copies, we use jemalloc’s <code class="highlighter-rouge">*allocx()</code>-APIs to create, modify and free
aligned allocations. One of the typical tasks where this gives us a major
speedup is on the incremental construction of an Arrow table that consists of
several columns. We often don’t know the size of the table in advance and need
to expand our allocations as the data is loaded.</p>

<p>To incrementally build a vector using memory expansion of a factor of 2, we
would use the following C-code with the standard POSIX APIs:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">aligned_alloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">aligned_alloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">ptr2</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">;</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre>
</div>

<p>With jemalloc’s special APIs, we are able to omit the explicit call to <code class="highlighter-rouge">memcpy</code>.
In the case where a memory expansion cannot be done in-place, it is still called
by the allocator but not needed on all occasions. This simplifies our user code
to:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mallocx</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">MALLOCX_ALIGN</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">size</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">rallocx</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">MALLOCX_ALIGN</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">dallocx</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">MALLOCX_ALIGN</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
</code></pre>
</div>

<p>To see the real world benefits of using jemalloc, we look at the benchmarks in
Arrow C++. There we have modeled a typical use case of incrementally building up
an array of primitive values. For the build-up of the array, we don’t know the
number of elements in the final array so we need to continuously expand the
memory region in which the data is stored. The code for this benchmark is part
of the <code class="highlighter-rouge">builder-benchmark</code> in the Arrow C++ sources as
<code class="highlighter-rouge">BuildPrimitiveArrayNoNulls</code>.</p>

<p>Runtimes without <code class="highlighter-rouge">jemalloc</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>BM_BuildPrimitiveArrayNoNulls/repeats:3                 636726 us   804.114MB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3                 621345 us   824.019MB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3                 625008 us    819.19MB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3_mean            627693 us   815.774MB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3_median          625008 us    819.19MB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3_stddev            8034 us   10.3829MB/s
</code></pre>
</div>

<p>Runtimes with <code class="highlighter-rouge">jemalloc</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>BM_BuildPrimitiveArrayNoNulls/repeats:3                 630881 us   811.563MB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3                 352891 us   1.41687GB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3                 351039 us   1.42434GB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3_mean            444937 us   1.21125GB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3_median          352891 us   1.41687GB/s
BM_BuildPrimitiveArrayNoNulls/repeats:3_stddev          161035 us   371.335MB/s
</code></pre>
</div>

<p>The benchmark was run three times for each configuration to see the performance
differences. The first run in each configuration yielded the same performance but
in all subsequent runs, the version using jemalloc was about twice as fast. In
these cases, the memory region that was used for constructing the array could be
expanded in place without moving the data around. This was possible as there
were memory pages assigned to the process that were unused but not reclaimed by
the operating system. Without <code class="highlighter-rouge">jemalloc</code>, we cannot make use of them simply by
the fact that the default allocator has no API that provides aligned
reallocation.</p>



    <hr/>
<footer class="footer">
  <p>Apache Arrow, Arrow, Apache, the Apache feather logo, and the Apache Arrow project logo are either registered trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
  <p>&copy; 2017 Apache Software Foundation</p>
</footer>

  </div>
</body>
</html>
