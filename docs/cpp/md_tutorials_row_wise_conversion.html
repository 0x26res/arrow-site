<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): row_wise_conversion</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">row_wise_conversion </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Convert a vector of row-wise data into an Arrow table </h1>
<p>While we want to use columnar data structures to build efficient operations, we often receive data in a row-wise fashion from other systems. In the following, we want give a brief introduction into the classes provided by Apache Arrow by showing how to transform row-wise data into a columnar table.</p>
<p>The data in this example is stored in the following struct:</p>
<div class="fragment"><div class="line">struct data_row {</div><div class="line">    int64_t id;</div><div class="line">    double cost;</div><div class="line">    std::vector&lt;double&gt; cost_components;</div><div class="line">};</div><div class="line"></div><div class="line">std::vector&lt;data_row&gt; rows;</div></div><!-- fragment --><p>The final representation should be an <code><a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays. ">arrow::Table</a></code> which in turn is made up of an <code><a class="el" href="classarrow_1_1_schema.html" title="Sequence of arrow::Field objects describing the columns of a record batch or table data structure...">arrow::Schema</a></code> and a list of <code><a class="el" href="classarrow_1_1_column.html" title="An immutable column data structure consisting of a field (type metadata) and a logical chunked data a...">arrow::Column</a></code>. An <code><a class="el" href="classarrow_1_1_column.html" title="An immutable column data structure consisting of a field (type metadata) and a logical chunked data a...">arrow::Column</a></code> is again a named collection of one or more <code><a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length. ">arrow::Array</a></code> instances. As the first step, we will iterate over the data and build up the arrays incrementally. For this task, we provide <code><a class="el" href="classarrow_1_1_array_builder.html" title="Base class for all data array builders. ">arrow::ArrayBuilder</a></code> classes that help in the construction of the final <code><a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length. ">arrow::Array</a></code> instances.</p>
<p>For each type, Arrow has a specially typed builder class. For the primitive values <code>id</code> and <code>cost</code> we can use the respective <code><a class="el" href="namespacearrow.html#a08fa80026c56e0f1ff24b43c4dc33e61">arrow::Int64Builder</a></code> and <code><a class="el" href="namespacearrow.html#ab98cad76b29efffe92c6c88af8947873">arrow::DoubleBuilder</a></code>. For the <code>cost_components</code> vector, we need to have two builders, a top-level <code><a class="el" href="classarrow_1_1_list_builder.html" title="Builder class for variable-length list array value types. ">arrow::ListBuilder</a></code> that builds the array of offsets and a nested <code><a class="el" href="namespacearrow.html#ab98cad76b29efffe92c6c88af8947873">arrow::DoubleBuilder</a></code> that constructs the underlying values array that is referenced by the offsets in the former array.</p>
<div class="fragment"><div class="line">// The builders are more efficient using</div><div class="line">// arrow::jemalloc::MemoryPool::default_pool() as this can increase the size of</div><div class="line">// the underlying memory regions in-place. At the moment, arrow::jemalloc is only</div><div class="line">// supported on Unix systems, not Windows.</div><div class="line"></div><div class="line">arrow::Int64Builder id_builder(arrow::default_memory_pool());</div><div class="line">arrow::DoubleBuilder cost_builder(arrow::default_memory_pool());</div><div class="line">std::shared_ptr&lt;DoubleBuilder&gt; components_values_builder =</div><div class="line">    std::make_shared&lt;DoubleBuilder&gt;(arrow::default_memory_pool());</div><div class="line">arrow::ListBuilder components_builder(arrow::default_memory_pool(),</div><div class="line">    components_values_builder);</div></div><!-- fragment --><p>Now we can loop over our existing data and insert it into the builders. The <code>Append</code> calls here may fail (e.g. we cannot allocate enough additional memory). Thus we need to check their return values. For more information on these values, check the documentation about <code><a class="el" href="classarrow_1_1_status.html">arrow::Status</a></code>.</p>
<div class="fragment"><div class="line">for (const data_row&amp; row : rows) {</div><div class="line">    ARROW_RETURN_NOT_OK(id_builder.Append(row.id));</div><div class="line">    ARROW_RETURN_NOT_OK(cost_builder.Append(row.cost));</div><div class="line"></div><div class="line">    // Indicate the start of a new list row. This will memorise the current</div><div class="line">    // offset in the values builder.</div><div class="line">    ARROW_RETURN_NOT_OK(components_builder.Append());</div><div class="line">    // Store the actual values. The final nullptr argument tells the underyling</div><div class="line">    // builder that all added values are valid, i.e. non-null.</div><div class="line">    ARROW_RETURN_NOT_OK(components_values_builder-&gt;Append(</div><div class="line">        row.cost_components.data(), row.cost_components.size(),</div><div class="line">        nullptr);</div><div class="line">}</div></div><!-- fragment --><p>At the end, we finalise the arrays, declare the (type) schema and combine them into a single <code><a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays. ">arrow::Table</a></code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;arrow::Array&gt; id_array;</div><div class="line">ARROW_RETURN_NOT_OK(id_builder.Finish(&amp;id_array));</div><div class="line">std::shared_ptr&lt;arrow::Array&gt; cost_array;</div><div class="line">ARROW_RETURN_NOT_OK(cost_builder.Finish(&amp;cost_array));</div><div class="line">std::shared_ptr&lt;arrow::Array&gt; cost_components_array;</div><div class="line">ARROW_RETURN_NOT_OK(components_builder.Finish(&amp;cost_components_array));</div><div class="line"></div><div class="line">std::vector&lt;std::shared_ptr&lt;arrow::Field&gt;&gt; schema_vector = {</div><div class="line">    arrow::field(&quot;id&quot;, arrow::int64()),</div><div class="line">    arrow::field(&quot;cost&quot;, arrow::float64()),</div><div class="line">    arrow::field(&quot;cost_components&quot;, arrow::list(arrow::float64()))</div><div class="line">};</div><div class="line">auto schema = std::make_shared&lt;arrow::Schema&gt;(schema_vector);</div><div class="line"></div><div class="line">std::shared_ptr&lt;arrow::Table&gt; table;</div><div class="line">ARROW_RETURN_NOT_OK(MakeTable(schema,</div><div class="line">    {id_array, cost_array, cost_components_array}, &amp;table));</div></div><!-- fragment --><p>The final <code>table</code> variable is the one we then can pass on to other functions that can consume Apache Arrow memory structures. This object has ownership of all referenced data, thus we don't have to care about undefined references once we leave the scope of the function building the table and its underlying arrays.</p>
<h1>Converting an Arrow Table back into row-wise representation </h1>
<p>To convert an Arrow table back into the same row-wise representation as in the above section, we first will check that the table conforms to our expected schema and then will build up the vector of rows incrementally.</p>
<p>For the check if the table is as expected, we can utilise solely its schema.</p>
<div class="fragment"><div class="line">// This is our input that was passed in from the outside.</div><div class="line">std::shared_ptr&lt;arrow::Table&gt; table;</div><div class="line"></div><div class="line">std::vector&lt;std::shared_ptr&lt;arrow::Field&gt;&gt; schema_vector = {</div><div class="line">    arrow::field(&quot;id&quot;, arrow::int64()),</div><div class="line">    arrow::field(&quot;cost&quot;, arrow::float64()),</div><div class="line">    arrow::field(&quot;cost_components&quot;, arrow::list(arrow::float64()))</div><div class="line">};</div><div class="line">auto expected_schema = std::make_shared&lt;arrow::Schema&gt;(schema_vector);</div><div class="line"></div><div class="line">if (!expected_schema-&gt;Equals(*table-&gt;schema())) {</div><div class="line">    // The table doesn&#39;t have the expected schema thus we cannot directly</div><div class="line">    // convert it to our target representation.</div><div class="line">    // TODO: Implement your custom error handling logic here.</div><div class="line">}</div></div><!-- fragment --><p>As we have ensured that the table has the expected structure, we can unpack the underlying arrays. For the primitive columns <code>id</code> and <code>cost</code> we can use the high level functions to get the values whereas for the nested column <code>cost_components</code> we need to access the C-pointer to the data to copy its contents into the resulting <code>std::vector&lt;double&gt;</code>. Here we need to be care to also add the offset to the pointer. This offset is needed to enable zero-copy slicing operations. While this could be adjusted automatically for double arrays, this cannot be done for the accompanying bitmap as often the slicing border would be inside a byte.</p>
<div class="fragment"><div class="line">// For simplicity, we assume that all arrays consist of a single chunk here.</div><div class="line">// In a productive implementation this should either be explicitly check or code</div><div class="line">// added that can treat chunked arrays.</div><div class="line"></div><div class="line">auto ids = std::static_pointer_cast&lt;arrow::Int64Array&gt;(</div><div class="line">    table-&gt;column(0)-&gt;data()-&gt;chunk(0));</div><div class="line">auto costs = std::static_pointer_cast&lt;arrow::DoubleArray(</div><div class="line">    table-&gt;column(1)-&gt;data()-&gt;chunk(0));</div><div class="line">auto cost_components = std::static_pointer_cast&lt;arrow::ListArray(</div><div class="line">    table-&gt;column(2)-&gt;data()-&gt;chunk(0));</div><div class="line">auto cost_components_values = std::static_pointer_cast&lt;arrow::DoubleArray&gt;(</div><div class="line">    cost_components-&gt;values());</div><div class="line">// To enable zero-copy slices, the native values pointer might need to account</div><div class="line">// for this slicing offset. This is not needed for the higher level functions</div><div class="line">// like Value(…) that already account for this offset internally.</div><div class="line">const double* cost_components_values_ptr = cost_components_values-&gt;data()</div><div class="line">    + cost_components_values-&gt;offset();</div></div><!-- fragment --><p>After we have unpacked the arrays from the table, we can iterate over them in a row-wise fashion and fill our target, row-wise representation.</p>
<div class="fragment"><div class="line">std::vector&lt;data_row&gt; rows;</div><div class="line"></div><div class="line">for (int64_t i = 0; i &lt; table-&gt;num_rows(); i++) {</div><div class="line">    // Another simplification in this example is that we assume that there are</div><div class="line">    // no null entries, e.g. each row is fill with valid values.</div><div class="line">    int64_t id = ids-&gt;Value(i);</div><div class="line">    double cost = costs-&gt;Value(i);</div><div class="line">    const double* first = cost_components_values_ptr + cost_components-&gt;value_offset(i);</div><div class="line">    const double* last = cost_components_values_ptr + cost_components-&gt;value_offset(i + 1);</div><div class="line">    std::vector&lt;double&gt; components_vec(first, last);</div><div class="line">    rows.push_back({id, cost, components_vec});</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
