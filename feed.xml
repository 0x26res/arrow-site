<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-08-31T11:43:33-04:00</updated><id>/</id><entry><title type="html">Apache Arrow 0.6.0 Release</title><link href="/blog/2017/08/16/0.6.0-release/" rel="alternate" type="text/html" title="Apache Arrow 0.6.0 Release" /><published>2017-08-16T00:00:00-04:00</published><updated>2017-08-16T00:00:00-04:00</updated><id>/blog/2017/08/16/0.6.0-release</id><content type="html" xml:base="/blog/2017/08/16/0.6.0-release/">&lt;!--

--&gt;

&lt;p&gt;The Apache Arrow team is pleased to announce the 0.6.0 release. It includes
&lt;a href=&quot;https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.6.0&quot;&gt;&lt;strong&gt;90 resolved JIRAs&lt;/strong&gt;&lt;/a&gt; with the new Plasma shared memory object store, and
improvements and bug fixes to the various language implementations. The Arrow
memory format remains stable since the 0.3.x release.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;http://arrow.apache.org/install&quot;&gt;Install Page&lt;/a&gt; to learn how to get the libraries for your
platform. The &lt;a href=&quot;http://arrow.apache.org/release/0.6.0.html&quot;&gt;complete changelog&lt;/a&gt; is also available.&lt;/p&gt;

&lt;h2 id=&quot;plasma-shared-memory-object-store&quot;&gt;Plasma Shared Memory Object Store&lt;/h2&gt;

&lt;p&gt;This release includes the &lt;a href=&quot;http://arrow.apache.org/blog/2017/08/08/plasma-in-memory-object-store/&quot;&gt;Plasma Store&lt;/a&gt;, which you can read more about in
the linked blog post. This system was originally developed as part of the &lt;a href=&quot;https://ray-project.github.io/ray/&quot;&gt;Ray
Project&lt;/a&gt; at the &lt;a href=&quot;https://rise.cs.berkeley.edu/&quot;&gt;UC Berkeley RISELab&lt;/a&gt;. We recognized that Plasma would be
highly valuable to the Arrow community as a tool for shared memory management
and zero-copy deserialization. Additionally, we believe we will be able to
develop a stronger software stack through sharing of IO and buffer management
code.&lt;/p&gt;

&lt;p&gt;The Plasma store is a server application which runs as a separate process. A
reference C++ client, with Python bindings, is made available in this
release. Clients can be developed in Java or other languages in the future to
enable simple sharing of complex datasets through shared memory.&lt;/p&gt;

&lt;h2 id=&quot;arrow-format-addition-map-type&quot;&gt;Arrow Format Addition: Map type&lt;/h2&gt;

&lt;p&gt;We added a Map logical type to represent ordered and unordered maps
in-memory. This corresponds to the &lt;code class=&quot;highlighter-rouge&quot;&gt;MAP&lt;/code&gt; logical type annotation in the Parquet
format (where maps are represented as repeated structs).&lt;/p&gt;

&lt;p&gt;Map is represented as a list of structs. It is the first example of a logical
type whose physical representation is a nested type. We have not yet created
implementations of Map containers in any of the implementations, but this can
be done in a future release.&lt;/p&gt;

&lt;p&gt;As an example, the Python data:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data = [{'a': 1, 'bb': 2, 'cc': 3}, {'dddd': 4}]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Could be represented in an Arrow &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&amp;lt;String, Int32&amp;gt;&lt;/code&gt; as:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Map&amp;lt;String, Int32&amp;gt; = List&amp;lt;Struct&amp;lt;keys: String, values: Int32&amp;gt;&amp;gt;
  is_valid: [true, true]
  offsets: [0, 3, 4]
  values: Struct&amp;lt;keys: String, values: Int32&amp;gt;
    children:
      - keys: String
          is_valid: [true, true, true, true]
          offsets: [0, 1, 3, 5, 9]
          data: abbccdddd
      - values: Int32
          is_valid: [true, true, true, true]
          data: [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;python-changes&quot;&gt;Python Changes&lt;/h2&gt;

&lt;p&gt;Some highlights of Python development outside of bug fixes and general API
improvements include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;New &lt;code class=&quot;highlighter-rouge&quot;&gt;strings_to_categorical=True&lt;/code&gt; option when calling &lt;code class=&quot;highlighter-rouge&quot;&gt;Table.to_pandas&lt;/code&gt; will
yield pandas &lt;code class=&quot;highlighter-rouge&quot;&gt;Categorical&lt;/code&gt; types from Arrow binary and string columns&lt;/li&gt;
  &lt;li&gt;Expanded Hadoop Filesystem (HDFS) functionality to improve compatibility with
Dask and other HDFS-aware Python libraries.&lt;/li&gt;
  &lt;li&gt;s3fs and other Dask-oriented filesystems can now be used with
&lt;code class=&quot;highlighter-rouge&quot;&gt;pyarrow.parquet.ParquetDataset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;More graceful handling of pandas’s nanosecond timestamps when writing to
Parquet format. You can now pass &lt;code class=&quot;highlighter-rouge&quot;&gt;coerce_timestamps='ms'&lt;/code&gt; to cast to
milliseconds, or &lt;code class=&quot;highlighter-rouge&quot;&gt;'us'&lt;/code&gt; for microseconds.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toward-arrow-100-and-beyond&quot;&gt;Toward Arrow 1.0.0 and Beyond&lt;/h2&gt;

&lt;p&gt;We are still discussing the roadmap to 1.0.0 release on the &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/arrow-dev/&quot;&gt;developer mailing
list&lt;/a&gt;. The focus of the 1.0.0 release will likely be memory format stability
and hardening integration tests across the remaining data types implemented in
Java and C++. Please join the discussion there.&lt;/p&gt;</content><author><name>wesm</name></author></entry><entry><title type="html">Plasma In-Memory Object Store</title><link href="/blog/2017/08/08/plasma-in-memory-object-store/" rel="alternate" type="text/html" title="Plasma In-Memory Object Store" /><published>2017-08-08T00:00:00-04:00</published><updated>2017-08-08T00:00:00-04:00</updated><id>/blog/2017/08/08/plasma-in-memory-object-store</id><content type="html" xml:base="/blog/2017/08/08/plasma-in-memory-object-store/">&lt;!--

--&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://people.eecs.berkeley.edu/~pcmoritz/&quot;&gt;Philipp Moritz&lt;/a&gt; and &lt;a href=&quot;http://www.robertnishihara.com&quot;&gt;Robert Nishihara&lt;/a&gt; are graduate students at UC
 Berkeley.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;plasma-a-high-performance-shared-memory-object-store&quot;&gt;Plasma: A High-Performance Shared-Memory Object Store&lt;/h2&gt;

&lt;h3 id=&quot;motivating-plasma&quot;&gt;Motivating Plasma&lt;/h3&gt;

&lt;p&gt;This blog post presents Plasma, an in-memory object store that is being
developed as part of Apache Arrow. &lt;strong&gt;Plasma holds immutable objects in shared
memory so that they can be accessed efficiently by many clients across process
boundaries.&lt;/strong&gt; In light of the trend toward larger and larger multicore machines,
Plasma enables critical performance optimizations in the big data regime.&lt;/p&gt;

&lt;p&gt;Plasma was initially developed as part of &lt;a href=&quot;https://github.com/ray-project/ray&quot;&gt;Ray&lt;/a&gt;, and has recently been moved
to Apache Arrow in the hopes that it will be broadly useful.&lt;/p&gt;

&lt;p&gt;One of the goals of Apache Arrow is to serve as a common data layer enabling
zero-copy data exchange between multiple frameworks. A key component of this
vision is the use of off-heap memory management (via Plasma) for storing and
sharing Arrow-serialized objects between applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expensive serialization and deserialization as well as data copying are a
common performance bottleneck in distributed computing.&lt;/strong&gt; For example, a
Python-based execution framework that wishes to distribute computation across
multiple Python “worker” processes and then aggregate the results in a single
“driver” process may choose to serialize data using the built-in &lt;code class=&quot;highlighter-rouge&quot;&gt;pickle&lt;/code&gt;
library. Assuming one Python process per core, each worker process would have to
copy and deserialize the data, resulting in excessive memory usage. The driver
process would then have to deserialize results from each of the workers,
resulting in a bottleneck.&lt;/p&gt;

&lt;p&gt;Using Plasma plus Arrow, the data being operated on would be placed in the
Plasma store once, and all of the workers would read the data without copying or
deserializing it (the workers would map the relevant region of memory into their
own address spaces). The workers would then put the results of their computation
back into the Plasma store, which the driver could then read and aggregate
without copying or deserializing the data.&lt;/p&gt;

&lt;h3 id=&quot;the-plasma-api&quot;&gt;The Plasma API:&lt;/h3&gt;

&lt;p&gt;Below we illustrate a subset of the API. The C++ API is documented more fully
&lt;a href=&quot;https://github.com/apache/arrow/blob/master/cpp/apidoc/tutorials/plasma.md&quot;&gt;here&lt;/a&gt;, and the Python API is documented &lt;a href=&quot;https://github.com/apache/arrow/blob/master/python/doc/source/plasma.rst&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object IDs:&lt;/strong&gt; Each object is associated with a string of bytes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Creating an object:&lt;/strong&gt; Objects are stored in Plasma in two stages. First, the
object store &lt;em&gt;creates&lt;/em&gt; the object by allocating a buffer for it. At this point,
the client can write to the buffer and construct the object within the allocated
buffer. When the client is done, the client &lt;em&gt;seals&lt;/em&gt; the buffer making the object
immutable and making it available to other Plasma clients.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Create an object.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;object_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pyarrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;plasma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;object_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoryview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Write to the buffer.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Seal the object making it immutable and available to other clients.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Getting an object:&lt;/strong&gt; After an object has been sealed, any client who knows the
object ID can get the object.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Get the object from the store. This blocks until the object has been sealed.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;object_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pyarrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;plasma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoryview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If the object has not been sealed yet, then the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;client.get&lt;/code&gt; will block
until the object has been sealed.&lt;/p&gt;

&lt;h3 id=&quot;a-sorting-application&quot;&gt;A sorting application&lt;/h3&gt;

&lt;p&gt;To illustrate the benefits of Plasma, we demonstrate an &lt;strong&gt;11x speedup&lt;/strong&gt; (on a
machine with 20 physical cores) for sorting a large pandas DataFrame (one
billion entries). The baseline is the built-in pandas sort function, which sorts
the DataFrame in 477 seconds. To leverage multiple cores, we implement the
following standard distributed sorting scheme.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We assume that the data is partitioned across K pandas DataFrames and that
each one already lives in the Plasma store.&lt;/li&gt;
  &lt;li&gt;We subsample the data, sort the subsampled data, and use the result to define
L non-overlapping buckets.&lt;/li&gt;
  &lt;li&gt;For each of the K data partitions and each of the L buckets, we find the
subset of the data partition that falls in the bucket, and we sort that
subset.&lt;/li&gt;
  &lt;li&gt;For each of the L buckets, we gather all of the K sorted subsets that fall in
that bucket.&lt;/li&gt;
  &lt;li&gt;For each of the L buckets, we merge the corresponding K sorted subsets.&lt;/li&gt;
  &lt;li&gt;We turn each bucket into a pandas DataFrame and place it in the Plasma store.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using this scheme, we can sort the DataFrame (the data starts and ends in the
Plasma store), in 44 seconds, giving an 11x speedup over the baseline.&lt;/p&gt;

&lt;h3 id=&quot;design&quot;&gt;Design&lt;/h3&gt;

&lt;p&gt;The Plasma store runs as a separate process. It is written in C++ and is
designed as a single-threaded event loop based on the &lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt; event loop library.
The plasma client library can be linked into applications. Clients communicate
with the Plasma store via messages serialized using &lt;a href=&quot;https://google.github.io/flatbuffers/&quot;&gt;Google Flatbuffers&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;call-for-contributions&quot;&gt;Call for contributions&lt;/h3&gt;

&lt;p&gt;Plasma is a work in progress, and the API is currently unstable. Today Plasma is
primarily used in &lt;a href=&quot;https://github.com/ray-project/ray&quot;&gt;Ray&lt;/a&gt; as an in-memory cache for Arrow serialized objects.
We are looking for a broader set of use cases to help refine Plasma’s API. In
addition, we are looking for contributions in a variety of areas including
improving performance and building other language bindings. Please let us know
if you are interested in getting involved with the project.&lt;/p&gt;</content><author><name>Philipp Moritz and Robert Nishihara</name></author></entry><entry><title type="html">Speeding up PySpark with Apache Arrow</title><link href="/blog/2017/07/26/spark-arrow/" rel="alternate" type="text/html" title="Speeding up PySpark with Apache Arrow" /><published>2017-07-26T12:00:00-04:00</published><updated>2017-07-26T12:00:00-04:00</updated><id>/blog/2017/07/26/spark-arrow</id><content type="html" xml:base="/blog/2017/07/26/spark-arrow/">&lt;!--

--&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/BryanCutler&quot;&gt;Bryan Cutler&lt;/a&gt; is a software engineer at IBM’s Spark Technology Center &lt;a href=&quot;http://www.spark.tc/&quot;&gt;STC&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Beginning with &lt;a href=&quot;https://spark.apache.org/&quot;&gt;Apache Spark&lt;/a&gt; version 2.3, &lt;a href=&quot;https://arrow.apache.org/&quot;&gt;Apache Arrow&lt;/a&gt; will be a supported
dependency and begin to offer increased performance with columnar data transfer.
If you are a Spark user that prefers to work in Python and Pandas, this is a cause
to be excited over! The initial work is limited to collecting a Spark DataFrame
with &lt;code class=&quot;highlighter-rouge&quot;&gt;toPandas()&lt;/code&gt;, which I will discuss below, however there are many additional
improvements that are currently &lt;a href=&quot;https://issues.apache.org/jira/issues/?filter=12335725&amp;amp;jql=project%20%3D%20SPARK%20AND%20status%20in%20(Open%2C%20%22In%20Progress%22%2C%20Reopened)%20AND%20text%20~%20%22arrow%22%20ORDER%20BY%20createdDate%20DESC&quot;&gt;underway&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;optimizing-spark-conversion-to-pandas&quot;&gt;Optimizing Spark Conversion to Pandas&lt;/h1&gt;

&lt;p&gt;The previous way of converting a Spark DataFrame to Pandas with &lt;code class=&quot;highlighter-rouge&quot;&gt;DataFrame.toPandas()&lt;/code&gt;
in PySpark was painfully inefficient. Basically, it worked by first collecting all
rows to the Spark driver. Next, each row would get serialized into Python’s pickle
format and sent to a Python worker process. This child process unpickles each row into
a huge list of tuples. Finally, a Pandas DataFrame is created from the list using
&lt;code class=&quot;highlighter-rouge&quot;&gt;pandas.DataFrame.from_records()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This all might seem like standard procedure, but suffers from 2 glaring issues: 1)
even using CPickle, Python serialization is a slow process and 2) creating
a &lt;code class=&quot;highlighter-rouge&quot;&gt;pandas.DataFrame&lt;/code&gt; using &lt;code class=&quot;highlighter-rouge&quot;&gt;from_records&lt;/code&gt; must slowly iterate over the list of pure
Python data and convert each value to Pandas format. See &lt;a href=&quot;https://gist.github.com/wesm/0cb5531b1c2e346a0007&quot;&gt;here&lt;/a&gt; for a detailed
analysis.&lt;/p&gt;

&lt;p&gt;Here is where Arrow really shines to help optimize these steps: 1) Once the data is
in Arrow memory format, there is no need to serialize/pickle anymore as Arrow data can
be sent directly to the Python process, 2) When the Arrow data is received in Python,
then pyarrow can utilize zero-copy methods to create a &lt;code class=&quot;highlighter-rouge&quot;&gt;pandas.DataFrame&lt;/code&gt; from entire
chunks of data at once instead of processing individual scalar values. Additionally,
the conversion to Arrow data can be done on the JVM and pushed back for the Spark
executors to perform in parallel, drastically reducing the load on the driver.&lt;/p&gt;

&lt;p&gt;As of the merging of &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-13534&quot;&gt;SPARK-13534&lt;/a&gt;, the use of Arrow when calling &lt;code class=&quot;highlighter-rouge&quot;&gt;toPandas()&lt;/code&gt;
needs to be enabled by setting the SQLConf “spark.sql.execution.arrow.enable” to
“true”.  Let’s look at a simple usage example.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Welcome to
      ____              __
     / __/__  ___ _____/ /__
    _\ \/ _ \/ _ `/ __/  '_/
   /__ / .__/\_,_/_/ /_/\_\   version 2.3.0-SNAPSHOT
      /_/

Using Python version 2.7.13 (default, Dec 20 2016 23:09:15)
SparkSession available as 'spark'.

In [1]: from pyspark.sql.functions import rand
   ...: df = spark.range(1 &amp;lt;&amp;lt; 22).toDF(&quot;id&quot;).withColumn(&quot;x&quot;, rand())
   ...: df.printSchema()
   ...: 
root
 |-- id: long (nullable = false)
 |-- x: double (nullable = false)


In [2]: %time pdf = df.toPandas()
CPU times: user 17.4 s, sys: 792 ms, total: 18.1 s
Wall time: 20.7 s

In [3]: spark.conf.set(&quot;spark.sql.execution.arrow.enable&quot;, &quot;true&quot;)

In [4]: %time pdf = df.toPandas()
CPU times: user 40 ms, sys: 32 ms, total: 72 ms                                 
Wall time: 737 ms

In [5]: pdf.describe()
Out[5]: 
                 id             x
count  4.194304e+06  4.194304e+06
mean   2.097152e+06  4.998996e-01
std    1.210791e+06  2.887247e-01
min    0.000000e+00  8.291929e-07
25%    1.048576e+06  2.498116e-01
50%    2.097152e+06  4.999210e-01
75%    3.145727e+06  7.498380e-01
max    4.194303e+06  9.999996e-01
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This example was run locally on my laptop using Spark defaults so the times
shown should not be taken precisely. Even though, it is clear there is a huge
performance boost and using Arrow took something that was excruciatingly slow
and speeds it up to be barely noticeable.&lt;/p&gt;

&lt;h1 id=&quot;notes-on-usage&quot;&gt;Notes on Usage&lt;/h1&gt;

&lt;p&gt;Here are some things to keep in mind before making use of this new feature. At
the time of writing this, pyarrow will not be installed automatically with
pyspark and needs to be manually installed, see installation &lt;a href=&quot;https://github.com/apache/arrow/blob/master/site/install.md&quot;&gt;instructions&lt;/a&gt;.
It is planned to add pyarrow as a pyspark dependency so that 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt; pip install pyspark&lt;/code&gt; will also install pyarrow.&lt;/p&gt;

&lt;p&gt;Currently, the controlling SQLConf is disabled by default. This can be enabled
programmatically as in the example above or by adding the line
“spark.sql.execution.arrow.enable=true” to &lt;code class=&quot;highlighter-rouge&quot;&gt;SPARK_HOME/conf/spark-defaults.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also, not all Spark data types are currently supported and limited to primitive
types. Expanded type support is in the works and expected to also be in the Spark
2.3 release.&lt;/p&gt;

&lt;h1 id=&quot;future-improvements&quot;&gt;Future Improvements&lt;/h1&gt;

&lt;p&gt;As mentioned, this was just a first step in using Arrow to make life easier for
Spark Python users. A few exciting initiatives in the works are to allow for
vectorized UDF evaluation (&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-21190&quot;&gt;SPARK-21190&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-21404&quot;&gt;SPARK-21404&lt;/a&gt;), and the ability
to apply a function on grouped data using a Pandas DataFrame (&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-20396&quot;&gt;SPARK-20396&lt;/a&gt;).
Just as Arrow helped in converting a Spark to Pandas, it can also work in the
other direction when creating a Spark DataFrame from an existing Pandas
DataFrame (&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-20791&quot;&gt;SPARK-20791&lt;/a&gt;). Stay tuned for more!&lt;/p&gt;

&lt;h1 id=&quot;collaborators&quot;&gt;Collaborators&lt;/h1&gt;

&lt;p&gt;Reaching this first milestone was a group effort from both the Apache Arrow and
Spark communities. Thanks to the hard work of &lt;a href=&quot;https://github.com/wesm&quot;&gt;Wes McKinney&lt;/a&gt;, &lt;a href=&quot;https://github.com/icexelloss&quot;&gt;Li Jin&lt;/a&gt;,
&lt;a href=&quot;https://github.com/holdenk&quot;&gt;Holden Karau&lt;/a&gt;, Reynold Xin, Wenchen Fan, Shane Knapp and many others that
helped push this effort forwards.&lt;/p&gt;</content><author><name>BryanCutler</name></author></entry><entry><title type="html">Apache Arrow 0.5.0 Release</title><link href="/blog/2017/07/25/0.5.0-release/" rel="alternate" type="text/html" title="Apache Arrow 0.5.0 Release" /><published>2017-07-25T00:00:00-04:00</published><updated>2017-07-25T00:00:00-04:00</updated><id>/blog/2017/07/25/0.5.0-release</id><content type="html" xml:base="/blog/2017/07/25/0.5.0-release/">&lt;!--

--&gt;

&lt;p&gt;The Apache Arrow team is pleased to announce the 0.5.0 release. It includes
&lt;a href=&quot;https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.5.0&quot;&gt;&lt;strong&gt;130 resolved JIRAs&lt;/strong&gt;&lt;/a&gt; with some new features, expanded integration
testing between implementations, and bug fixes. The Arrow memory format remains
stable since the 0.3.x and 0.4.x releases.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;http://arrow.apache.org/install&quot;&gt;Install Page&lt;/a&gt; to learn how to get the libraries for your
platform. The &lt;a href=&quot;http://arrow.apache.org/release/0.5.0.html&quot;&gt;complete changelog&lt;/a&gt; is also available.&lt;/p&gt;

&lt;h2 id=&quot;expanded-integration-testing&quot;&gt;Expanded Integration Testing&lt;/h2&gt;

&lt;p&gt;In this release, we added compatibility tests for dictionary-encoded data
between Java and C++. This enables the distinct values (the &lt;em&gt;dictionary&lt;/em&gt;) in a
vector to be transmitted as part of an Arrow schema while the record batches
contain integers which correspond to the dictionary.&lt;/p&gt;

&lt;p&gt;So we might have:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data (string): ['foo', 'bar', 'foo', 'bar']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In dictionary-encoded form, this could be represented as:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;indices (int8): [0, 1, 0, 1]
dictionary (string): ['foo', 'bar']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In upcoming releases, we plan to complete integration testing for the remaining
data types (including some more complicated types like unions and decimals) on
the road to a 1.0.0 release in the future.&lt;/p&gt;

&lt;h2 id=&quot;c-activity&quot;&gt;C++ Activity&lt;/h2&gt;

&lt;p&gt;We completed a number of significant pieces of work in the C++ part of Apache
Arrow.&lt;/p&gt;

&lt;h3 id=&quot;using-jemalloc-as-default-memory-allocator&quot;&gt;Using jemalloc as default memory allocator&lt;/h3&gt;

&lt;p&gt;We decided to use &lt;a href=&quot;https://github.com/jemalloc/jemalloc&quot;&gt;jemalloc&lt;/a&gt; as the default memory allocator unless it is
explicitly disabled. This memory allocator has significant performance
advantages in Arrow workloads over the default &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt; implementation. We will
publish a blog post going into more detail about this and why you might care.&lt;/p&gt;

&lt;h3 id=&quot;sharing-more-c-code-with-apache-parquet&quot;&gt;Sharing more C++ code with Apache Parquet&lt;/h3&gt;

&lt;p&gt;We imported the compression library interfaces and dictionary encoding
algorithms from the &lt;a href=&quot;http://github.com/apache/parquet-cpp&quot;&gt;Apache Parquet C++ library&lt;/a&gt;. The Parquet library now
depends on this code in Arrow, and we will be able to use it more easily for
data compression in Arrow use cases.&lt;/p&gt;

&lt;p&gt;As part of incorporating Parquet’s dictionary encoding utilities, we have
developed an &lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::DictionaryBuilder&lt;/code&gt; class to enable building
dictionary-encoded arrays iteratively. This can help save memory and yield
better performance when interacting with databases, Parquet files, or other
sources which may have columns having many duplicates.&lt;/p&gt;

&lt;h3 id=&quot;support-for-lz4-and-zstd-compressors&quot;&gt;Support for LZ4 and ZSTD compressors&lt;/h3&gt;

&lt;p&gt;We added LZ4 and ZSTD compression library support. In ARROW-300 and other
planned work, we intend to add some compression features for data sent via RPC.&lt;/p&gt;

&lt;h2 id=&quot;python-activity&quot;&gt;Python Activity&lt;/h2&gt;

&lt;p&gt;We fixed many bugs which were affecting Parquet and Feather users and fixed
several other rough edges with normal Arrow use. We also added some additional
Arrow type conversions: structs, lists embedded in pandas objects, and Arrow
time types (which deserialize to the &lt;code class=&quot;highlighter-rouge&quot;&gt;datetime.time&lt;/code&gt; type).&lt;/p&gt;

&lt;p&gt;In upcoming releases we plan to continue to improve &lt;a href=&quot;http://github.com/dask/dask&quot;&gt;Dask&lt;/a&gt; support and
performance for distributed processing of Apache Parquet files with pyarrow.&lt;/p&gt;

&lt;h2 id=&quot;the-road-ahead&quot;&gt;The Road Ahead&lt;/h2&gt;

&lt;p&gt;We have much work ahead of us to build out Arrow integrations in other data
systems to improve their processing performance and interoperability with other
systems.&lt;/p&gt;

&lt;p&gt;We are discussing the roadmap to a future 1.0.0 release on the &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/arrow-dev/&quot;&gt;developer
mailing list&lt;/a&gt;. Please join the discussion there.&lt;/p&gt;</content><author><name>wesm</name></author></entry><entry><title type="html">Connecting Relational Databases to the Apache Arrow World with turbodbc</title><link href="/blog/2017/06/16/turbodbc-arrow/" rel="alternate" type="text/html" title="Connecting Relational Databases to the Apache Arrow World with turbodbc" /><published>2017-06-16T04:00:00-04:00</published><updated>2017-06-16T04:00:00-04:00</updated><id>/blog/2017/06/16/turbodbc-arrow</id><content type="html" xml:base="/blog/2017/06/16/turbodbc-arrow/">&lt;!--

--&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/mathmagique&quot;&gt;Michael König&lt;/a&gt; is the lead developer of the &lt;a href=&quot;https://github.com/blue-yonder/turbodbc&quot;&gt;turbodbc project&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://arrow.apache.org/&quot;&gt;Apache Arrow&lt;/a&gt; project set out to become the universal data layer for
column-oriented data processing systems without incurring serialization costs
or compromising on performance on a more general level. While relational
databases still lag behind in Apache Arrow adoption, the Python database module
&lt;a href=&quot;https://github.com/blue-yonder/turbodbc&quot;&gt;turbodbc&lt;/a&gt; brings Apache Arrow support to these databases using a much
older, more specialized data exchange layer: &lt;a href=&quot;https://en.wikipedia.org/wiki/Open_Database_Connectivity&quot;&gt;ODBC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;ODBC is a database interface that offers developers the option to transfer data
either in row-wise or column-wise fashion. Previous Python ODBC modules typically
use the row-wise approach, and often trade repeated database roundtrips for simplified
buffer handling. This makes them less suited for data-intensive applications,
particularly when interfacing with modern columnar analytical databases.&lt;/p&gt;

&lt;p&gt;In contrast, turbodbc was designed to leverage columnar data processing from day
one. Naturally, this implies using the columnar portion of the ODBC API. Equally
important, however, is to find new ways of providing columnar data to Python users
that exceed the capabilities of the row-wise API mandated by Python’s &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;PEP 249&lt;/a&gt;.
Turbodbc has adopted Apache Arrow for this very task with the recently released
version 2.0.0:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;turbodbc&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dsn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;My columnar database&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cursor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cursor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cursor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SELECT some_integers, some_strings FROM my_table&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cursor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetchallarrow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pyarrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Table&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;some_integers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int64&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;some_strings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;With this new addition, the data flow for a result set of a typical SELECT query
is like this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The database prepares the result set and exposes it to the ODBC driver using
either row-wise or column-wise storage.&lt;/li&gt;
  &lt;li&gt;Turbodbc has the ODBC driver write chunks of the result set into columnar buffers.&lt;/li&gt;
  &lt;li&gt;These buffers are exposed to turbodbc’s Apache Arrow frontend. This frontend
will create an Arrow table and fill in the buffered values.&lt;/li&gt;
  &lt;li&gt;The previous steps are repeated until the entire result set is retrieved.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/turbodbc_arrow.png&quot; alt=&quot;Data flow from relational databases to Python with turbodbc and the Apache Arrow frontend&quot; class=&quot;img-responsive&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In practice, it is possible to achieve the following ideal situation: A 64-bit integer
column is stored as one contiguous block of memory in a columnar database. A huge chunk
of 64-bit integers is transferred over the network and the ODBC driver directly writes
it to a turbodbc buffer of 64-bit integers. The Arrow frontend accumulates these values
by copying the entire 64-bit buffer into a free portion of an Arrow table’s 64-bit
integer column.&lt;/p&gt;

&lt;p&gt;Moving data from the database to an Arrow table and, thus, providing it to the Python
user can be as simple as copying memory blocks around, megabytes equivalent to hundred
thousands of rows at a time. The absence of serialization and conversion logic renders
the process extremely efficient.&lt;/p&gt;

&lt;p&gt;Once the data is stored in an Arrow table, Python users can continue to do some
actual work. They can convert it into a &lt;a href=&quot;https://arrow.apache.org/docs/python/pandas.html&quot;&gt;Pandas DataFrame&lt;/a&gt; for data analysis
(using a quick &lt;code class=&quot;highlighter-rouge&quot;&gt;table.to_pandas()&lt;/code&gt;), pass it on to other data processing
systems such as &lt;a href=&quot;http://spark.apache.org/&quot;&gt;Apache Spark&lt;/a&gt; or &lt;a href=&quot;http://impala.apache.org/&quot;&gt;Apache Impala (incubating)&lt;/a&gt;, or store
it in the &lt;a href=&quot;http://parquet.apache.org/&quot;&gt;Apache Parquet&lt;/a&gt; file format. This way, non-Python systems are
efficiently connected with relational databases.&lt;/p&gt;

&lt;p&gt;In the future, turbodbc’s Arrow support will be extended to use more
sophisticated features such as &lt;a href=&quot;https://arrow.apache.org/docs/memory_layout.html#dictionary-encoding&quot;&gt;dictionary-encoded&lt;/a&gt; string fields. We also
plan to pick smaller than 64-bit &lt;a href=&quot;https://arrow.apache.org/docs/metadata.html#integers&quot;&gt;data types&lt;/a&gt; where possible. Last but not
least, Arrow support will be extended to cover the reverse direction of data
flow, so that Python users can quickly insert Arrow tables into relational
databases.&lt;/p&gt;

&lt;p&gt;If you would like to learn more about turbodbc, check out the &lt;a href=&quot;https://github.com/blue-yonder/turbodbc&quot;&gt;GitHub project&lt;/a&gt; and the
&lt;a href=&quot;http://turbodbc.readthedocs.io/&quot;&gt;project documentation&lt;/a&gt;. If you want to learn more about how turbodbc implements the
nitty-gritty details, check out parts &lt;a href=&quot;https://tech.blue-yonder.com/making-of-turbodbc-part-1-wrestling-with-the-side-effects-of-a-c-api/&quot;&gt;one&lt;/a&gt; and &lt;a href=&quot;https://tech.blue-yonder.com/making-of-turbodbc-part-2-c-to-python/&quot;&gt;two&lt;/a&gt; of the
&lt;a href=&quot;https://tech.blue-yonder.com/making-of-turbodbc-part-1-wrestling-with-the-side-effects-of-a-c-api/&quot;&gt;“Making of turbodbc”&lt;/a&gt; series at &lt;a href=&quot;https://tech.blue-yonder.com/&quot;&gt;Blue Yonder’s technology blog&lt;/a&gt;.&lt;/p&gt;</content><author><name>MathMagique</name></author></entry><entry><title type="html">Apache Arrow 0.4.1 Release</title><link href="/blog/2017/06/14/0.4.1-release/" rel="alternate" type="text/html" title="Apache Arrow 0.4.1 Release" /><published>2017-06-14T10:00:00-04:00</published><updated>2017-06-14T10:00:00-04:00</updated><id>/blog/2017/06/14/0.4.1-release</id><content type="html" xml:base="/blog/2017/06/14/0.4.1-release/">&lt;!--

--&gt;

&lt;p&gt;The Apache Arrow team is pleased to announce the 0.4.1 release of the
project. This is a bug fix release that addresses a regression with Decimal
types in the Java implementation introduced in 0.4.0 (see
&lt;a href=&quot;https://issues.apache.org/jira/browse/ARROW-1091&quot;&gt;ARROW-1091&lt;/a&gt;). There were a total of &lt;a href=&quot;https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.4.1&quot;&gt;31 resolved JIRAs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;http://arrow.apache.org/install&quot;&gt;Install Page&lt;/a&gt; to learn how to get the libraries for your platform.&lt;/p&gt;

&lt;h3 id=&quot;python-wheel-installers-for-windows&quot;&gt;Python Wheel Installers for Windows&lt;/h3&gt;

&lt;p&gt;Max Risuhin contributed fixes to enable binary wheel installers to be generated
for Python 3.5 and 3.6. Thus, 0.4.1 is the first Arrow release for which
PyArrow including bundled &lt;a href=&quot;http://parquet.apache.org&quot;&gt;Apache Parquet&lt;/a&gt; support that can be installed
with either conda or pip across the 3 major platforms: Linux, macOS, and
Windows. Use one of:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install pyarrow
conda install pyarrow -c conda-forge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;turbodbc-200-with-apache-arrow-support&quot;&gt;Turbodbc 2.0.0 with Apache Arrow Support&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://turbodbc.readthedocs.io/&quot;&gt;Turbodbc&lt;/a&gt;, a fast C++ ODBC interface with Python bindings, released
version 2.0.0 including reading SQL result sets as Arrow record batches. The
team used the PyArrow C++ API introduced in version 0.4.0 to construct
&lt;code class=&quot;highlighter-rouge&quot;&gt;pyarrow.Table&lt;/code&gt; objects inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;turbodbc&lt;/code&gt; library. Learn more in their
&lt;a href=&quot;http://turbodbc.readthedocs.io/en/latest/pages/advanced_usage.html#apache-arrow-support&quot;&gt;documentation&lt;/a&gt; and install with one of:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install turbodbc
conda install turbodbc -c conda-forge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>wesm</name></author></entry><entry><title type="html">Apache Arrow 0.4.0 Release</title><link href="/blog/2017/05/23/0.4.0-release/" rel="alternate" type="text/html" title="Apache Arrow 0.4.0 Release" /><published>2017-05-23T00:00:00-04:00</published><updated>2017-05-23T00:00:00-04:00</updated><id>/blog/2017/05/23/0.4.0-release</id><content type="html" xml:base="/blog/2017/05/23/0.4.0-release/">&lt;!--

--&gt;

&lt;p&gt;The Apache Arrow team is pleased to announce the 0.4.0 release of the
project. While only 17 days since the release, it includes &lt;a href=&quot;https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.4.0&quot;&gt;&lt;strong&gt;77 resolved
JIRAs&lt;/strong&gt;&lt;/a&gt; with some important new features and bug fixes.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;http://arrow.apache.org/install&quot;&gt;Install Page&lt;/a&gt; to learn how to get the libraries for your platform.&lt;/p&gt;

&lt;h3 id=&quot;expanded-javascript-implementation&quot;&gt;Expanded JavaScript Implementation&lt;/h3&gt;

&lt;p&gt;The TypeScript Arrow implementation has undergone some work since 0.3.0 and can
now read a substantial portion of the Arrow streaming binary format. As this
implementation develops, we will eventually want to include JS in the
integration test suite along with Java and C++ to ensure wire
cross-compatibility.&lt;/p&gt;

&lt;h3 id=&quot;python-support-for-apache-parquet-on-windows&quot;&gt;Python Support for Apache Parquet on Windows&lt;/h3&gt;

&lt;p&gt;With the &lt;a href=&quot;https://github.com/apache/parquet-cpp/releases/tag/apache-parquet-cpp-1.1.0&quot;&gt;1.1.0 C++ release&lt;/a&gt; of &lt;a href=&quot;http://parquet.apache.org&quot;&gt;Apache Parquet&lt;/a&gt;, we have enabled the
&lt;code class=&quot;highlighter-rouge&quot;&gt;pyarrow.parquet&lt;/code&gt; extension on Windows for Python 3.5 and 3.6. This should
appear in conda-forge packages and PyPI in the near future. Developers can
follow the &lt;a href=&quot;http://arrow.apache.org/docs/python/development.html&quot;&gt;source build instructions&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;generalizing-arrow-streams&quot;&gt;Generalizing Arrow Streams&lt;/h3&gt;

&lt;p&gt;In the 0.2.0 release, we defined the first version of the Arrow streaming
binary format for low-cost messaging with columnar data. These streams presume
that the message components are written as a continuous byte stream over a
socket or file.&lt;/p&gt;

&lt;p&gt;We would like to be able to support other other transport protocols, like
&lt;a href=&quot;http://grpc.io/&quot;&gt;gRPC&lt;/a&gt;, for the message components of Arrow streams. To that end, in C++ we
defined an abstract stream reader interface, for which the current contiguous
streaming format is one implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RecordBatchReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Schema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetNextRecordBatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RecordBatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It would also be good to define abstract stream reader and writer interfaces in
the Java implementation.&lt;/p&gt;

&lt;p&gt;In an upcoming blog post, we will explain in more depth how Arrow streams work,
but you can learn more about them by reading the &lt;a href=&quot;http://arrow.apache.org/docs/ipc.html&quot;&gt;IPC specification&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;c-and-cython-api-for-python-extensions&quot;&gt;C++ and Cython API for Python Extensions&lt;/h3&gt;

&lt;p&gt;As other Python libraries with C or C++ extensions use Apache Arrow, they will
need to be able to return Python objects wrapping the underlying C++
objects. In this release, we have implemented a prototype C++ API which enables
Python wrapper objects to be constructed from C++ extension code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;arrow/python/pyarrow.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;import_pyarrow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Error
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RecordBatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpp_batch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;py_batch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrap_batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp_batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This API is intended to be usable from Cython code as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cython&quot; data-lang=&quot;cython&quot;&gt;cimport pyarrow
pyarrow.import_pyarrow()&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;python-wheel-installers-on-macos&quot;&gt;Python Wheel Installers on macOS&lt;/h3&gt;

&lt;p&gt;With this release, &lt;code class=&quot;highlighter-rouge&quot;&gt;pip install pyarrow&lt;/code&gt; works on macOS (OS X) as well as
Linux. We are working on providing binary wheel installers for Windows as well.&lt;/p&gt;</content><author><name>wesm</name></author></entry><entry><title type="html">Apache Arrow 0.3.0 Release</title><link href="/blog/2017/05/08/0.3-release/" rel="alternate" type="text/html" title="Apache Arrow 0.3.0 Release" /><published>2017-05-08T00:00:00-04:00</published><updated>2017-05-08T00:00:00-04:00</updated><id>/blog/2017/05/08/0.3-release</id><content type="html" xml:base="/blog/2017/05/08/0.3-release/">&lt;!--

--&gt;

&lt;p&gt;Translations: &lt;a href=&quot;/blog/2017/05/08/0.3-release-japanese/&quot;&gt;日本語&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The Apache Arrow team is pleased to announce the 0.3.0 release of the
project. It is the product of an intense 10 weeks of development since the
0.2.0 release from this past February. It includes &lt;a href=&quot;https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.3.0&quot;&gt;&lt;strong&gt;306 resolved JIRAs&lt;/strong&gt;&lt;/a&gt;
from &lt;a href=&quot;https://github.com/apache/arrow/graphs/contributors&quot;&gt;&lt;strong&gt;23 contributors&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While we have added many new features to the different Arrow implementations,
one of the major development focuses in 2017 has been hardening the in-memory
format, type metadata, and messaging protocol to provide a &lt;strong&gt;stable,
production-ready foundation&lt;/strong&gt; for big data applications. We are excited to be
collaborating with the &lt;a href=&quot;http://spark.apache.org&quot;&gt;Apache Spark&lt;/a&gt; and &lt;a href=&quot;http://www.geomesa.org/&quot;&gt;GeoMesa&lt;/a&gt; communities on
utilizing Arrow for high performance IO and in-memory data processing.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;http://arrow.apache.org/install&quot;&gt;Install Page&lt;/a&gt; to learn how to get the libraries for your platform.&lt;/p&gt;

&lt;p&gt;We will be publishing more information about the Apache Arrow roadmap as we
forge ahead with using Arrow to accelerate big data systems.&lt;/p&gt;

&lt;p&gt;We are looking for more contributors from within our existing communities and
from other communities (such as Go, R, or Julia) to get involved in Arrow
development.&lt;/p&gt;

&lt;h3 id=&quot;file-and-streaming-format-hardening&quot;&gt;File and Streaming Format Hardening&lt;/h3&gt;

&lt;p&gt;The 0.2.0 release brought with it the first iterations of the &lt;strong&gt;random access&lt;/strong&gt;
and &lt;strong&gt;streaming&lt;/strong&gt; Arrow wire formats. See the &lt;a href=&quot;http://arrow.apache.org/docs/ipc.html&quot;&gt;IPC specification&lt;/a&gt; for
implementation details and &lt;a href=&quot;http://wesmckinney.com/blog/arrow-streaming-columnar/&quot;&gt;example blog post&lt;/a&gt; with some use cases. These
provide low-overhead, zero-copy access to Arrow record batch payloads.&lt;/p&gt;

&lt;p&gt;In 0.3.0 we have solidified a number of small details with the binary format
and improved our integration and unit testing particularly in the Java, C++,
and Python libraries. Using the &lt;a href=&quot;http://github.com/google/flatbuffers&quot;&gt;Google Flatbuffers&lt;/a&gt; project has helped with
adding new features to our metadata without breaking forward compatibility.&lt;/p&gt;

&lt;p&gt;We are not yet ready to make a firm commitment to strong forward compatibility
(in case we find something needs to change) in the binary format, but we will
make efforts between major releases to not make unnecessary
breakages. Contributions to the website and component user and API
documentation would also be most welcome.&lt;/p&gt;

&lt;h3 id=&quot;dictionary-encoding-support&quot;&gt;Dictionary Encoding Support&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/elahrvivaz&quot;&gt;Emilio Lahr-Vivaz&lt;/a&gt; from the &lt;a href=&quot;http://www.geomesa.org/&quot;&gt;GeoMesa&lt;/a&gt; project contributed Java support
for dictionary-encoded Arrow vectors. We followed up with C++ and Python
support (and &lt;code class=&quot;highlighter-rouge&quot;&gt;pandas.Categorical&lt;/code&gt; integration). We have not yet implemented
full integration tests for dictionaries (for sending this data between C++ and
Java), but hope to achieve this in the 0.4.0 Arrow release.&lt;/p&gt;

&lt;p&gt;This common data representation technique for categorical data allows multiple
record batches to share a common “dictionary”, with the values in the batches
being represented as integers referencing the dictionary. This data is called
“categorical” or “factor” in statistical languages, while in file formats like
Apache Parquet it is strictly used for data compression.&lt;/p&gt;

&lt;h3 id=&quot;expanded-date-time-and-fixed-size-types&quot;&gt;Expanded Date, Time, and Fixed Size Types&lt;/h3&gt;

&lt;p&gt;A notable omission from the 0.2.0 release was complete and integration-tested
support for the gamut of date and time types that occur in the wild. These are
needed for &lt;a href=&quot;http://parquet.apache.org&quot;&gt;Apache Parquet&lt;/a&gt; and Apache Spark integration.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Date&lt;/strong&gt;: 32-bit (days unit) and 64-bit (milliseconds unit)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Time&lt;/strong&gt;: 64-bit integer with unit (second, millisecond, microsecond, nanosecond)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Timestamp&lt;/strong&gt;: 64-bit integer with unit, with or without timezone&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fixed Size Binary&lt;/strong&gt;: Primitive values occupying certain number of bytes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fixed Size List&lt;/strong&gt;: List values with constant size (no separate offsets vector)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have additionally added experimental support for exact decimals in C++ using
&lt;a href=&quot;https://github.com/boostorg/multiprecision&quot;&gt;Boost.Multiprecision&lt;/a&gt;, though we have not yet hardened the Decimal memory
format between the Java and C++ implementations.&lt;/p&gt;

&lt;h3 id=&quot;c-and-python-support-on-windows&quot;&gt;C++ and Python Support on Windows&lt;/h3&gt;

&lt;p&gt;We have made many general improvements to development and packaging for general
C++ and Python development. 0.3.0 is the first release to bring full C++ and
Python support for Windows on Visual Studio (MSVC) 2015 and 2017. In addition
to adding Appveyor continuous integration for MSVC, we have also written guides
for building from source on Windows: &lt;a href=&quot;https://github.com/apache/arrow/blob/master/cpp/apidoc/Windows.md&quot;&gt;C++&lt;/a&gt; and &lt;a href=&quot;https://github.com/apache/arrow/blob/master/python/doc/source/development.rst&quot;&gt;Python&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the first time, you can install the Arrow Python library on Windows from
&lt;a href=&quot;https://conda-forge.github.io&quot;&gt;conda-forge&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;conda install pyarrow -c conda-forge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c-glib-bindings-with-support-for-ruby-lua-and-more&quot;&gt;C (GLib) Bindings, with support for Ruby, Lua, and more&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/kou&quot;&gt;Kouhei Sutou&lt;/a&gt; is a new Apache Arrow contributor and has contributed GLib C
bindings (to the C++ libraries) for Linux. Using a C middleware framework
called &lt;a href=&quot;https://wiki.gnome.org/Projects/GObjectIntrospection&quot;&gt;GObject Introspection&lt;/a&gt;, it is possible to use these bindings
seamlessly in Ruby, Lua, Go, and &lt;a href=&quot;https://wiki.gnome.org/Projects/GObjectIntrospection/Users&quot;&gt;other programming languages&lt;/a&gt;. We will
probably need to publish some follow up blogs explaining how these bindings
work and how to use them.&lt;/p&gt;

&lt;h3 id=&quot;apache-spark-integration-for-pyspark&quot;&gt;Apache Spark Integration for PySpark&lt;/h3&gt;

&lt;p&gt;We have been collaborating with the Apache Spark community on &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-13534&quot;&gt;SPARK-13534&lt;/a&gt;
to add support for using Arrow to accelerate &lt;code class=&quot;highlighter-rouge&quot;&gt;DataFrame.toPandas&lt;/code&gt; in
PySpark. We have observed over &lt;a href=&quot;https://github.com/apache/spark/pull/15821#issuecomment-282175163&quot;&gt;&lt;strong&gt;40x speedup&lt;/strong&gt;&lt;/a&gt; from the more efficient
data serialization.&lt;/p&gt;

&lt;p&gt;Using Arrow in PySpark opens the door to many other performance optimizations,
particularly around UDF evaluation (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; operations with
Python lambda functions).&lt;/p&gt;

&lt;h3 id=&quot;new-python-feature-memory-views-feather-apache-parquet-support&quot;&gt;New Python Feature: Memory Views, Feather, Apache Parquet support&lt;/h3&gt;

&lt;p&gt;Arrow’s Python library &lt;code class=&quot;highlighter-rouge&quot;&gt;pyarrow&lt;/code&gt; is a Cython binding for the &lt;code class=&quot;highlighter-rouge&quot;&gt;libarrow&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;libarrow_python&lt;/code&gt; C++ libraries, which handle inteoperability with NumPy,
&lt;a href=&quot;http://pandas.pydata.org&quot;&gt;pandas&lt;/a&gt;, and the Python standard library.&lt;/p&gt;

&lt;p&gt;At the heart of Arrow’s C++ libraries is the &lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::Buffer&lt;/code&gt; object, which is a
managed memory view supporting zero-copy reads and slices. &lt;a href=&quot;https://github.com/JeffKnupp&quot;&gt;Jeff Knupp&lt;/a&gt;
contributed integration between Arrow buffers and the Python buffer protocol
and memoryviews, so now code like this is possible:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pyarrow&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pa&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frombuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'foobarbaz'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pyarrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7f6c0a84b538&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoryview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7f6c0a8c5e88&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_pybytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'foobarbaz'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We have significantly expanded &lt;a href=&quot;http://parquet.apache.org&quot;&gt;&lt;strong&gt;Apache Parquet&lt;/strong&gt;&lt;/a&gt; support via the C++
Parquet implementation &lt;a href=&quot;https://github.com/apache/parquet-cpp&quot;&gt;parquet-cpp&lt;/a&gt;. This includes support for partitioned
datasets on disk or in HDFS. We added initial Arrow-powered Parquet support &lt;a href=&quot;https://github.com/dask/dask/commit/68f9e417924a985c1f2e2a587126833c70a2e9f4&quot;&gt;in
the Dask project&lt;/a&gt;, and look forward to more collaborations with the Dask
developers on distributed processing of pandas data.&lt;/p&gt;

&lt;p&gt;With Arrow’s support for pandas maturing, we were able to merge in the
&lt;a href=&quot;https://github.com/wesm/feather&quot;&gt;&lt;strong&gt;Feather format&lt;/strong&gt;&lt;/a&gt; implementation, which is essentially a special case of
the Arrow random access format. We’ll be continuing Feather development within
the Arrow codebase. For example, Feather can now read and write with Python
file objects using Arrow’s Python binding layer.&lt;/p&gt;

&lt;p&gt;We also implemented more robust support for pandas-specific data types, like
&lt;code class=&quot;highlighter-rouge&quot;&gt;DatetimeTZ&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Categorical&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;support-for-tensors-and-beyond-in-c-library&quot;&gt;Support for Tensors and beyond in C++ Library&lt;/h3&gt;

&lt;p&gt;There has been increased interest in using Apache Arrow as a tool for zero-copy
shared memory management for machine learning applications. A flagship example
is the &lt;a href=&quot;https://github.com/ray-project/ray&quot;&gt;Ray project&lt;/a&gt; from the UC Berkeley &lt;a href=&quot;https://rise.cs.berkeley.edu/&quot;&gt;RISELab&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Machine learning deals in additional kinds of data structures beyond what the
Arrow columnar format supports, like multidimensional arrays aka “tensors”. As
such, we implemented the &lt;a href=&quot;http://arrow.apache.org/docs/cpp/classarrow_1_1_tensor.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::Tensor&lt;/code&gt;&lt;/a&gt; C++ type which can utilize the
rest of Arrow’s zero-copy shared memory machinery (using &lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::Buffer&lt;/code&gt; for
managing memory lifetime). In C++ in particular, we will want to provide for
additional data structures utilizing common IO and memory management tools.&lt;/p&gt;

&lt;h3 id=&quot;start-of-javascript-typescript-implementation&quot;&gt;Start of JavaScript (TypeScript) Implementation&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/TheNeuralBit&quot;&gt;Brian Hulette&lt;/a&gt; started developing an Arrow implementation in
&lt;a href=&quot;https://github.com/apache/arrow/tree/master/js&quot;&gt;TypeScript&lt;/a&gt; for use in NodeJS and browser-side applications. We are
benefitting from Flatbuffers’ first class support for JavaScript.&lt;/p&gt;

&lt;h3 id=&quot;improved-website-and-developer-documentation&quot;&gt;Improved Website and Developer Documentation&lt;/h3&gt;

&lt;p&gt;Since 0.2.0 we have implemented a new website stack for publishing
documentation and blogs based on &lt;a href=&quot;https://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;. Kouhei Sutou developed a &lt;a href=&quot;https://github.com/red-data-tools/jekyll-jupyter-notebook&quot;&gt;Jekyll
Jupyter Notebook plugin&lt;/a&gt; so that we can use Jupyter to author content for
the Arrow website.&lt;/p&gt;

&lt;p&gt;On the website, we have now published API documentation for the C, C++, Java,
and Python subcomponents. Within these you will find easier-to-follow developer
instructions for getting started.&lt;/p&gt;

&lt;h3 id=&quot;contributors&quot;&gt;Contributors&lt;/h3&gt;

&lt;p&gt;Thanks to all who contributed patches to this release.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git shortlog -sn apache-arrow-0.2.0..apache-arrow-0.3.0
    119 Wes McKinney
     55 Kouhei Sutou
     18 Uwe L. Korn
     17 Julien Le Dem
      9 Phillip Cloud
      6 Bryan Cutler
      5 Philipp Moritz
      5 Emilio Lahr-Vivaz
      4 Max Risuhin
      4 Johan Mabille
      4 Jeff Knupp
      3 Steven Phillips
      3 Miki Tebeka
      2 Leif Walsh
      2 Jeff Reback
      2 Brian Hulette
      1 Tsuyoshi Ozawa
      1 rvernica
      1 Nong Li
      1 Julien Lafaye
      1 Itai Incze
      1 Holden Karau
      1 Deepak Majeti
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>wesm</name></author></entry><entry><title type="html">Apache Arrow 0.3.0リリース</title><link href="/blog/2017/05/08/0.3-release-japanese/" rel="alternate" type="text/html" title="Apache Arrow 0.3.0リリース" /><published>2017-05-08T00:00:00-04:00</published><updated>2017-05-08T00:00:00-04:00</updated><id>/blog/2017/05/08/0.3-release-japanese</id><content type="html" xml:base="/blog/2017/05/08/0.3-release-japanese/">&lt;!--

--&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/05/08/0.3-release/&quot;&gt;原文（English）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache Arrowチームは0.3.0のリリースをアナウンスできてうれしいです。2月にリリースした0.2.0から10週間の活発な開発の結果が今回のリリースです。&lt;a href=&quot;https://github.com/apache/arrow/graphs/contributors&quot;&gt;&lt;strong&gt;23人のコントリビューター&lt;/strong&gt;&lt;/a&gt;が&lt;a href=&quot;https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.3.0&quot;&gt;&lt;strong&gt;306個のJIRAのissueを解決&lt;/strong&gt;&lt;/a&gt;しました。&lt;/p&gt;

&lt;p&gt;複数のArrowの実装にたくさんの新しい機能を追加しています。2017年、特に注力して開発するのは、インメモリー用のフォーマット、型のメタデータ、メッセージング用のプロトコルです。これは、ビッグデータアプリケーションに&lt;strong&gt;安定していてプロダクションで使える基盤&lt;/strong&gt;を提供するためです。高性能IOとインメモリーデータ処理にArrowを活用するために、&lt;a href=&quot;http://spark.apache.org&quot;&gt;Apache Spark&lt;/a&gt;・&lt;a href=&quot;http://www.geomesa.org/&quot;&gt;GeoMesa&lt;/a&gt;コミュニティーと協力していてとてもエキサイティングです。&lt;/p&gt;

&lt;p&gt;それぞれのプラットフォームでArrowを使う方法は&lt;a href=&quot;http://arrow.apache.org/install&quot;&gt;インストールページ&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;Arrowでビッグデータシステムを高速化するケースを増やすために、近いうちにApache Arrowのロードマップを公開する予定です。&lt;/p&gt;

&lt;p&gt;Arrowの開発に参加するコントリビューターを募集しています。すでにArrowの開発に参加しているコミュニティーからのコントリビューターもそうですし、まだ参加していないGo、R、Juliaといったコミュニティーからのコントリビューターも募集しています。&lt;/p&gt;

&lt;h3 id=&quot;ファイルフォーマットとストリーミングフォーマットの強化&quot;&gt;ファイルフォーマットとストリーミングフォーマットの強化&lt;/h3&gt;

&lt;p&gt;0.2.0では&lt;strong&gt;ランダムアクセス&lt;/strong&gt;用と&lt;strong&gt;ストリーミング&lt;/strong&gt;用のArrowのワイヤーフォーマットを導入しました。実装の詳細は&lt;a href=&quot;http://arrow.apache.org/docs/ipc.html&quot;&gt;IPC仕様&lt;/a&gt;を見てください。ユースケースは&lt;a href=&quot;http://wesmckinney.com/blog/arrow-streaming-columnar/&quot;&gt;使用例を紹介したブログ&lt;/a&gt;を見てください。これらのフォーマットを使うと低オーバーヘッド・コピーなしでArrowのレコードバッチのペイロードにアクセスできます。&lt;/p&gt;

&lt;p&gt;0.3.0ではこのバイナリーフォマットの細かい詳細をたくさん固めました。Java、C++、Python間の連携のテストおよびそれぞれ言語での単体テストの整備も進めました。&lt;a href=&quot;http://github.com/google/flatbuffers&quot;&gt;Google Flatbuffers&lt;/a&gt;は、前方互換性を壊さずにメタデータに新しい機能を追加するのに非常に助かりました。&lt;/p&gt;

&lt;p&gt;まだバイナリーフォーマットの前方互換性を必ず壊さないと約束できる状態ではありませんが（もしかしたら変更する必要があるなにかが見つかるかもしれない）、メジャーリリース間では不必要に互換性を壊さないように努力するつもりです。Apache ArrowのWebサイト、各コンポーネントのユーザー向けのドキュメントおよびAPIドキュメントへのコントリビューションを非常に歓迎します。&lt;/p&gt;

&lt;h3 id=&quot;辞書エンコーディングのサポート&quot;&gt;辞書エンコーディングのサポート&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.geomesa.org/&quot;&gt;GeoMesa&lt;/a&gt;プロジェクトの&lt;a href=&quot;https://github.com/elahrvivaz&quot;&gt;Emilio Lahr-Vivaz&lt;/a&gt;はJavaのArrow実装に辞書エンコード対応ベクターをコントリビュートしました。これを受けて、C++とPythonでもサポートしました。（&lt;code class=&quot;highlighter-rouge&quot;&gt;pandas.Categorical&lt;/code&gt;とも連携できます。）辞書エンコーディング用のインテグレーションテスト（C++とJava間でこのデータを送受信するテスト）はまだ完成していませんが、0.4.0までには完成させたいです。&lt;/p&gt;

&lt;p&gt;これはカテゴリーデータ用の一般的なデータ表現テクニックです。これを使うと、複数のレコードバッチで共通の「辞書」を共有し、各レコードバッチの値はこの辞書を参照する整数になります。このデータは統計的言語（statistical language）の分野では「カテゴリー（categorical）」や「因子（factor）」と呼ばれています。Apache Parquetのようなファイルフォーマットの分野ではデータ圧縮のためだけに使われています。&lt;/p&gt;

&lt;h3 id=&quot;日付時刻固定長型の拡張&quot;&gt;日付、時刻、固定長型の拡張&lt;/h3&gt;

&lt;p&gt;0.2.0では現実に使われている日付・時刻型をインテグレーションテスト付きで完全にサポートすることを諦めました。これらは&lt;a href=&quot;http://parquet.apache.org&quot;&gt;Apache Parquet&lt;/a&gt;とApache Sparkとの連携に必要な機能です。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;日付&lt;/strong&gt;: 32-bit（日単位）と64-bit（ミリ秒単位）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;時刻&lt;/strong&gt;: 単位付き64-bit整数（単位：秒、ミリ秒、マイクロ秒、ナノ秒）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;タイムスタンプ（UNIXエポックからの経過時間）&lt;/strong&gt;: 単位付き64-bit整数のタイムゾーン付きとタイムゾーンなし&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;固定長バイナリー&lt;/strong&gt;: 決まったバイト数のプリミティブな値&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;固定長リスト&lt;/strong&gt;: 各要素が同じサイズのリスト（要素のベクターとは別にオフセットのベクターを持つ必要がない）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++のArrow実装では、&lt;a href=&quot;https://github.com/boostorg/multiprecision&quot;&gt;Boost.Multiprecision&lt;/a&gt;を使ったexactな小数のサポートを実験的に追加しました。ただし、Java実装とC++実装間での小数のメモリーフォーマットはまだ固まっていません。&lt;/p&gt;

&lt;h3 id=&quot;cとpythonのwindowsサポート&quot;&gt;C++とPythonのWindowsサポート&lt;/h3&gt;

&lt;p&gt;一般的なC++とPythonでの開発用に、パッケージ周りの改良も多数入っています。0.3.0はVisual Studio（MSVC）2015と2017を使ってWindowsを完全にサポートした最初のバージョンです。AppveyorでMSVC用のCIを実行しています。Windows上でソースからビルドするためのガイドも書きました。&lt;a href=&quot;https://github.com/apache/arrow/blob/master/cpp/apidoc/Windows.md&quot;&gt;C++&lt;/a&gt;用と&lt;a href=&quot;https://github.com/apache/arrow/blob/master/python/doc/source/development.rst&quot;&gt;Python&lt;/a&gt;用。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://conda-forge.github.io&quot;&gt;conda-forge&lt;/a&gt;からWindows用のArrowのPythonライブラリーをインストールできます。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;conda install pyarrow -c conda-forge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cglibバインディングとrubylua他のサポート&quot;&gt;C（GLib）バインディングとRuby・Lua・他のサポート&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/kou&quot;&gt;Kouhei Sutou&lt;/a&gt;は新しいApache Arrowのコントリビューターです。Linux用の（ArrowのC++実装の）GLibを使ったCバインディングをコントリビュートしました。&lt;a href=&quot;https://wiki.gnome.org/Projects/GObjectIntrospection&quot;&gt;GObject Introspection&lt;/a&gt;というCのミドルウェアを使うことでRuby、Lua、Goや&lt;a href=&quot;https://wiki.gnome.org/Projects/GObjectIntrospection/Users&quot;&gt;他にも様々なプログラミング言語&lt;/a&gt;でシームレスにバインディングを使うことができます。これらのバインディングがどのように動いているか、これらのバインディングをどのように使うかを説明するブログ記事が別途必要な気がします。&lt;/p&gt;

&lt;h3 id=&quot;pysparkを使ったapache-sparkとの連携&quot;&gt;PySparkを使ったApache Sparkとの連携&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-13534&quot;&gt;SPARK-13534&lt;/a&gt;でApache Sparkコミュニティーと協力しています。PySparkでの&lt;code class=&quot;highlighter-rouge&quot;&gt;DataFrame.toPandas&lt;/code&gt;をArrowを使って高速化しようとしています。効率的なデータのシリアライズにより&lt;a href=&quot;https://github.com/apache/spark/pull/15821#issuecomment-282175163&quot;&gt;&lt;strong&gt;40倍以上高速化&lt;/strong&gt;&lt;/a&gt;できるケースがあります。&lt;/p&gt;

&lt;p&gt;PySparkでArrowを使うことでこれまでできなかったパフォーマンス最適化の道が開けました。特に、UDFの評価まわりでいろいろやれることがあるでしょう。（たとえば、Pythonのラムダ関数を使って&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;・&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;を実行するケース。）&lt;/p&gt;

&lt;h3 id=&quot;python実装での新しい機能メモリービューfeatherapache-parquetのサポート&quot;&gt;Python実装での新しい機能：メモリービュー、Feather、Apache Parquetのサポート&lt;/h3&gt;

&lt;p&gt;ArrowのPythonライブラリーである&lt;code class=&quot;highlighter-rouge&quot;&gt;pyarrow&lt;/code&gt;は&lt;code class=&quot;highlighter-rouge&quot;&gt;libarrow&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;libarrow_python&lt;/code&gt;というC++ライブラリーのCythonバインディングです。&lt;code class=&quot;highlighter-rouge&quot;&gt;pyarrow&lt;/code&gt;はNumPyと&lt;a href=&quot;http://pandas.pydata.org&quot;&gt;pandas&lt;/a&gt;とPythonの標準ライブラリー間のシームレスな連携を実現します。&lt;/p&gt;

&lt;p&gt;ArrowのC++ライブラリーで最も重要なものは&lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::Buffer&lt;/code&gt;オブジェクトです。これはメモリービューを管理します。コピーなしの読み込みとスライスをサポートしている点が重要です。&lt;a href=&quot;https://github.com/JeffKnupp&quot;&gt;Jeff Knupp&lt;/a&gt;はArrowのバッファーとPythonのバッファープロトコルとmemoryviewの連携処理をコントリビュートしました。これにより次のようなことができるようになりました。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pyarrow&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pa&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frombuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'foobarbaz'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pyarrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7f6c0a84b538&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoryview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7f6c0a8c5e88&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_pybytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'foobarbaz'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C++でのParquet実装である&lt;a href=&quot;https://github.com/apache/parquet-cpp&quot;&gt;parquet-cpp&lt;/a&gt;を使うことで大幅に&lt;a href=&quot;http://parquet.apache.org&quot;&gt;&lt;strong&gt;Apache Parquet&lt;/strong&gt;&lt;/a&gt;サポートを改良しました。たとえば、ディスク上にあるかHDFS上にあるか関係なく、パーティションされたデータセットをサポートしました。&lt;a href=&quot;https://github.com/dask/dask/commit/68f9e417924a985c1f2e2a587126833c70a2e9f4&quot;&gt;Daskプロジェクト&lt;/a&gt;はArrowを使ったParquetサポートを実装した最初のプロジェクトです。Dask開発者とはpandsデータを分散処理する文脈でさらに協力できることを楽しみにしています。&lt;/p&gt;

&lt;p&gt;pandasを成熟させるためにArrowを改良することもあり、&lt;a href=&quot;https://github.com/wesm/feather&quot;&gt;&lt;strong&gt;Featherフォーマット&lt;/strong&gt;&lt;/a&gt;の実装をマージしたのもその1つです。Featherフォーマットは本質的にはArrowのランダムアクセスフォーマットの特別なケースの1つです。ArrowのコードベースでFeatherの開発を続けます。たとえば、今のFeatherはArrowのPythonバインディングのレイヤーを使うことでPythonのファイルオブジェクトを読み書きできるようになっています。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DatetimeTZ&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;Categorical&lt;/code&gt;といったpandas固有のデータ型のちゃんとした（robust）サポートも実装しました。&lt;/p&gt;

&lt;h3 id=&quot;cライブラリーでのテンソルサポート&quot;&gt;C++ライブラリーでのテンソルサポート&lt;/h3&gt;

&lt;p&gt;Apache Arrowはコピーなしで共有メモリーを管理するツールという側面があります。機械学習アプリケーションの文脈でこの機能への関心が増えています。UCバークレー校の&lt;a href=&quot;https://rise.cs.berkeley.edu/&quot;&gt;RISELab&lt;/a&gt;の&lt;a href=&quot;https://github.com/ray-project/ray&quot;&gt;Rayプロジェクト&lt;/a&gt;が最初の例です。&lt;/p&gt;

&lt;p&gt;機械学習ではは「テンソル」とも呼ばれる多次元配列というデータ構造を扱います。このようなデータ構造はArrowのカラムフォーマットがサポートしているデータ構造の範囲を超えています。今回のケースでは、&lt;a href=&quot;http://arrow.apache.org/docs/cpp/classarrow_1_1_tensor.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::Tensor&lt;/code&gt;&lt;/a&gt;というC++の型を追加で実装しました。これはArrowのコピーなしの共有メモリー機能を活用して実装しました。（メモリーの生存期間の管理に&lt;code class=&quot;highlighter-rouge&quot;&gt;arrow::Buffer&lt;/code&gt;を使いました。）C++実装では、これからも、共通のIO・メモリー管理ツールとしてArrowを活用できるようにするため、追加のデータ構造を提供するつもりです。&lt;/p&gt;

&lt;h3 id=&quot;javascripttypescript実装の開始&quot;&gt;JavaScript（TypeScript）実装の開始&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/TheNeuralBit&quot;&gt;Brian Hulette&lt;/a&gt;はNodeJSとWebブラウザー上で動くアプリケーションで使うために&lt;a href=&quot;https://github.com/apache/arrow/tree/master/js&quot;&gt;TypeScript&lt;/a&gt;でのArrowの実装を始めました。FlatBuffersがJavaScriptをファーストクラスでサポートしているので実装が捗ります。&lt;/p&gt;

&lt;h3 id=&quot;webサイトと開発者用ドキュメントの改良&quot;&gt;Webサイトと開発者用ドキュメントの改良&lt;/h3&gt;

&lt;p&gt;0.2.0をリリースしてからドキュメントとブログを公開するためにWebサイトのシステムを&lt;a href=&quot;https://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;ベースで作りました。Kouhei Sutouは&lt;a href=&quot;https://github.com/red-data-tools/jekyll-jupyter-notebook&quot;&gt;Jekyll Jupyter Notebookプラグイン&lt;/a&gt;を作りました。これによりArrowのWebサイトのコンテンツを作るためにJupyterを使うことができます。&lt;/p&gt;

&lt;p&gt;WebサイトにはC、C++、Java、PythonのAPIドキュメントを公開しました。これらの中にArrowを使い始めるための有益な情報を見つけられるでしょう。&lt;/p&gt;

&lt;h3 id=&quot;コントリビューター&quot;&gt;コントリビューター&lt;/h3&gt;

&lt;p&gt;このリリースにパッチをコントリビュートしたみなさんに感謝します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git shortlog -sn apache-arrow-0.2.0..apache-arrow-0.3.0
    119 Wes McKinney
     55 Kouhei Sutou
     18 Uwe L. Korn
     17 Julien Le Dem
      9 Phillip Cloud
      6 Bryan Cutler
      5 Philipp Moritz
      5 Emilio Lahr-Vivaz
      4 Max Risuhin
      4 Johan Mabille
      4 Jeff Knupp
      3 Steven Phillips
      3 Miki Tebeka
      2 Leif Walsh
      2 Jeff Reback
      2 Brian Hulette
      1 Tsuyoshi Ozawa
      1 rvernica
      1 Nong Li
      1 Julien Lafaye
      1 Itai Incze
      1 Holden Karau
      1 Deepak Majeti
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>wesm</name></author></entry></feed>